installation typeScript globally =>npm i typescript -g
check installation of the typeScript => tsc --version
run typeScript then run command  => tsc file_name (run this cmd then create copy of the ts file convert to js files)


set up typeScript project =>
what is tsConfig.json =>A tsconfig.json file is a configuration file used in TypeScript projects to define project settings and guide the TypeScript compiler (tsc) on how to compile the TypeScript code into JavaScript. 

cmd=> tsc --init

run the cmd => tsc --watch
==============================================================================================================================================================================================================

Basic Types in TS 
• Primative data types =>number , string , boolean
• Arrays
• Tuples
• Enums
• Any , Unknown, Void, Null, Undefined, Never






Arrays =>







Tuples => 

let arr:[number,string] = [1,2,323,'hey','ram']





Enums =>(enumerations)

enum UserRole {
    ADMIN = "admin",
    USER = "user",
    SUPER_ADMIN = 'super_admin"
}


any:=>Disables Type Checking: any completely disables type checking for the variable. You can assign any value to it, and perform any operation on it without TypeScript raising an error.
Potential Runtime Errors: Because of the lack of type checking, any can lead to runtime errors if you try to perform operations on the variable that are not compatible with its actual type.
Example: TypeScript
    let x: any = 10;
    x = "hello"; // No error
    x.toUpperCase(); // No error at compile time, but could cause a runtime error

unknown:=> Requires Type Checking: unknown is a safer alternative to any. It forces you to perform explicit type checks or assertions before performing operations on the variable.
Promotes Type Safety: By requiring type checks, unknown helps prevent runtime errors and encourages safer coding practices.
Example: TypeScript
    let y: unknown = 10;
    // y.toUpperCase(); // Compile-time error
    if (typeof y === 'string') {
        y.toUpperCase(); // No error because of the type check
    }





function => void number string boolean


// function return nothing used that
function abcd(): void {
  console.log('return Nothing use that type');
}
// if funtion return somethin then use this format
function mul(): number {
  return 12;
}



Null => 
let x: string | null;
x = 'sdfa'; // that is valid
// x = 12;// that is not valid  error :Type 'number' is not assignable to type 'string'



undefined => 
let y: undefined;




Never => never is genrally not used (never used genrally used when throw error not exucted remain code then we are used never )
function xyz(): never {
  while (true) {}
}
xyz();
console.log('never exuted this if we are user never means ');

// if we are not used never then console.log() line exucted otherwise not




// type narrowying =>



==============================================================================================================================================================================================================

Type Inference =>
• Understanding type Inference , ex => let a ='ram'; (auto type know the can Inference)
• type annotations , ex => let x:number | boolean| string; (define what is type then it is called annotations)

==============================================================================================================================================================================================================

Interfaces and type Aliases =>
• Defineing Interfaces =>

interface User {
  name: string;
  email: string;
  password: string;
  gender?: string;
}
function user(obj: User) {
  console.log(obj);
}
user({ name: 'krish', email: 'patel@gmail.com', password: 'ram@gmail.com' });




interface abcd{
  name:string;
}
interface abcd{
  email:string
}

both are combine and make online one interface => 
ex=> interface abcd{
  name:string;
  email:string
}

function abd(obj:abcd){
  obj.name="ram";
  obj.email="ram@gmail.com
}




xxxxxxx======================Learn-Day-2=========================================================================================================================xxxxxxx
Classes and Object =>
• class Definition: A class in TypeScript is a blueprint for creating objects with specific properties and methods.
  Example:
  class Person {
    name: string;
    constructor(name: string) {
    this.name = name;
    }
  }

• Constructor: A special method for creating and initializing objects created with a class.
  Example:
  class Car {
    model: string;
    constructor(model: string) {
    this.model = model;
    }
  }

• Access modifiers (public, private, protected): Keywords that control the visibility of class members.
  - public: Accessible from anywhere (default).
  - private: Accessible only within the class.
  - protected: Accessible within the class and its subclasses.
  Example:
  class Example {
    public a: number;
    private b: number;
    protected c: number;
  }

• ReadOnly Properties: Properties that can only be assigned once, usually in the constructor.
  Example:
  class Book {
    readonly title: string;
    constructor(title: string) {
    this.title = title;
    }
  }

• Optional Properties: Properties that may or may not be present in a class.
  Example:
  class User {
    name: string;
    age?: number; // optional
    constructor(name: string, age?: number) {
    this.name = name;
    this.age = age;
    }
  }

• Parameter Properties: Shorthand for declaring and initializing properties directly in the constructor parameters.
  Example:
  class Point {
    constructor(public x: number, public y: number) {}
  }

• Getters and Setters: Special methods to get and set the values of private properties.
  Example:
  class Employee {
    private _salary: number = 0;
    get salary(): number {
    return this._salary;
    }
    set salary(value: number) {
    if (value > 0) this._salary = value;
    }
  }

• Static members: Properties or methods that belong to the class itself, not to instances.
  Example:
  class MathUtil {
    static PI = 3.14;
    static square(x: number) {
    return x * x;
    }
  }

• Abstract classes and methods: Abstract classes cannot be instantiated directly and may contain abstract methods that must be implemented by subclasses.
  Example:
  abstract class Animal {
    abstract makeSound(): void;
    move(): void {
    console.log("Moving...");
    }
  }
  class Dog extends Animal {
    makeSound() {
    console.log("Woof!");
    }
  }

